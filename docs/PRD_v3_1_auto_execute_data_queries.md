# PRD v3.1: Auto-Execute Data Queries with Tabular Results

**Status:** Draft
**Created:** 2025-01-09
**Last Updated:** 2025-01-09
**Author:** Claude (with user collaboration)
**Target Release:** v3.1

---

## Overview

### Problem Statement

HealthUp currently has two distinct behaviors for SQL generation based on query type:

1. **Plot Queries** (`query_type: 'plot_query'`):
   - SQL is generated by LLM
   - Backend automatically executes SQL via `/api/execute-sql`
   - Results rendered as interactive Chart.js visualization
   - SQL query visible in text box above chart
   - User gets immediate visual insights

2. **Data Queries** (`query_type: 'data_query'`):
   - SQL is generated by LLM
   - SQL displayed in text box
   - **NOT executed automatically**
   - User must manually copy SQL and execute elsewhere
   - No results visible in UI

**Issues:**
- **Inconsistent UX:** Plot queries show results immediately, data queries require manual execution
- **Friction:** Non-technical users cannot see query results (don't know how to execute SQL)
- **SQL clutter:** Technical SQL syntax visible to all users, even those who don't need it
- **Incomplete loop:** User asks question → LLM generates SQL → user sees SQL but not the answer
- **Underutilized infrastructure:** Backend already has secure SQL execution endpoint, just not used for data queries

**Example scenario:**
```
User asks: "покажи мне мой последний холестерин" (show me my latest cholesterol)

Current behavior:
✓ LLM generates SQL
✓ SQL displayed in text box
✗ User sees SQL code, not the actual answer
✗ User must copy SQL and execute manually

Desired behavior:
✓ LLM generates SQL
✓ SQL executed automatically
✓ User sees: "Your latest cholesterol: 5.2 ммоль/л on Jan 5, 2025"
✓ SQL hidden (available in logs for debugging)
```

### Goals

1. **Execute data queries automatically:** Run `data_query` SQL on backend, same as plot queries
2. **Display results in tabular format:** Reuse existing parameter table styling (Date, Value, Unit, Reference Interval)
3. **Remove SQL from UI:** Hide SQL completely from user-facing interface (keep in server logs only)
4. **Maintain consistency:** Keep plot query behavior unchanged
5. **Improve usability:** Non-technical users see actual data answers, not SQL code

### Non-Goals (Out of Scope)

- Changes to plot query behavior (plots remain as-is)
- CSV export functionality
- Client-side sorting or filtering
- Pagination for large result sets
- Mobile-specific layout optimizations (basic horizontal scroll for tables is in scope)
- New database schema or indexes
- Custom table formatting per question type
- SQL visibility toggle (complete removal from UI, not optional)
- Query regeneration button (removed for simplicity)

---

## Current State Analysis

### SQL Generation Flow

**Agentic SQL Generator** (`server/services/agenticSqlGenerator.js:380-774`):
- LLM generates SQL through tool-calling loop
- Returns `{ sql, query_type, explanation, ... }`
- Two query types: `data_query` (default) and `plot_query`

**Query Type Differentiation:**
- **`data_query`**: Tabular results (current: SQL only, no execution)
  - LIMIT: 50 rows (enforced in `sqlValidator.js`)
  - Use cases: "show my latest X", "list all tests from 2024"

- **`plot_query`**: Time-series visualization (current: executed + rendered)
  - LIMIT: 10,000 rows
  - Required columns: `t`, `y`, `parameter_name`, `unit`
  - Use cases: "show cholesterol trend", "how has my vitamin D changed"

### Current Execution Infrastructure

**SQL Execution Endpoint** (`server/routes/executeSql.js:46-187`):
- **Already exists** for plot queries
- Security validation: 4 layers (regex, EXPLAIN plan, LIMIT enforcement, timeout)
- Returns: `{ ok: true, rows: [...], rowCount: N, fields: [...] }`
- Used by: Plot visualization flow only

**SQL Validator** (`server/services/sqlValidator.js`):
- Enforces read-only operations (forbids INSERT, UPDATE, DELETE, DROP, etc.)
- Injects/clamps LIMIT clause (50 for data, 10,000 for plots)
- 1-second EXPLAIN timeout, 30-second execution timeout
- No changes needed (already handles both query types)

### Current Frontend Display

**SQL Query Display** (`public/js/app.js:1251-1358`):
- SQL text box (`#sql-output`): Shows generated SQL
- Explanation box (`#sql-notes`): LLM's explanation
- Copy button: Copy SQL to clipboard
- Regenerate button: Re-run generation

**Plot Query Display** (`public/js/app.js:998-1249`):
- SQL hidden by default (not displayed prominently)
- Chart rendered via `plotRenderer.renderPlot()`
- Parameter table below chart (Date, Value, Unit, Reference Interval)

**Parameter Table** (`public/js/app.js:767-905`):
- Reusable table format with 4 columns
- Out-of-range highlighting (red outline on Value cell)
- Existing CSS classes: `.parameters-table`, `.parameters-table-wrapper`

---

## Proposed Solution

### Design Principles

1. **Consistent execution:** All SQL queries execute automatically (data queries and plot queries)
2. **SQL transparency:** SQL hidden from UI, visible only in server logs for debugging
3. **Reuse existing components:** Leverage parameter table styling and execution endpoint
4. **No feature regression:** Plot queries remain unchanged
5. **Progressive disclosure:** Show row counts and pagination hints
6. **Server-only SQL (data queries):** Data-query SQL stays on the backend (logged for debugging) and is never sent to the browser or exposed via dev tools

### High-Level Flow

```
User Question
     ↓
POST /api/sql-generator → Returns { sql, query_type, explanation }
     ↓
     ├─ query_type === 'plot_query' → Execute SQL → Render chart + table (unchanged)
     │
     └─ query_type === 'data_query' → Execute SQL → Render results table (NEW)
                                       ↓
                              Display: Date | Value | Unit | Reference Interval
                              + Row count message
                              + Error handling
```

### Key Changes

**Backend:**
- Modify `POST /api/sql-generator` job processing to execute `data_query` SQL
- Count total rows available (before LIMIT applied)
- Log SQL server-side only and return execution metadata without exposing SQL to the client

**Frontend:**
- Remove SQL text box (`#sql-output`) completely
- Remove SQL explanation box (`#sql-notes`) completely
- Remove "Copy SQL" button (no longer needed without SQL display)
- Remove "Regenerate" button (simplifies UI, rarely used)
- Add results table renderer for data queries
- Display row count message: "Showing 50 of X total rows" or "Found 12 rows"
- Update status messages based on query type

---

## Prerequisites

**CRITICAL:** This feature requires agentic SQL mode to be enabled. The `query_type` field is only returned by the agentic SQL generator, not the single-shot fallback mode.

**Environment Requirements:**
- `AGENTIC_SQL_ENABLED=true` (mandatory)
- If agentic mode is disabled, auto-execution will not work correctly

**Why Agentic Mode Required:**
- Single-shot mode returns: `{ ok, sql, explanation, metadata }` (no `query_type`)
- Agentic mode returns: `{ ok, sql, explanation, query_type, metadata }` (has `query_type`)
- Without `query_type`, backend cannot determine whether to execute automatically

**Fallback Behavior:**
If `query_type` is missing from response (e.g., during migration or if agentic mode disabled):
- Assume `query_type = 'data_query'` as safe default
- Execute data query and display results
- Log warning about missing query_type field

---

## Detailed Specification

**Note on Line Numbers:**
Line numbers referenced throughout this PRD (e.g., "lines 393-450", "line 1458") are approximate and based on the codebase state at PRD creation time. During implementation, these line numbers may shift due to code changes. Engineers should use function names, code context, and file structure to locate the referenced code sections rather than relying on exact line numbers.

### Backend Changes

#### SQL Generator Job Processing

**File:** `server/routes/sqlGenerator.js`

**Current behavior** (lines 74-110 in actual code):
```javascript
const { handleGeneration } = require('../services/sqlGenerator');
const { updateJob, setJobResult, setJobError, JobStatus } = require('../utils/jobManager');

// In setImmediate callback (lines 74-110)
setImmediate(async () => {
  try {
    updateJob(jobId, JobStatus.PROCESSING);

    const result = await handleGeneration({
      question,
      userIdentifier,
      model,
    });

    // result = { ok, sql, explanation, query_type, metadata, ... }
    // (agentic mode) or { ok, sql, explanation, metadata, ... } (single-shot)

    setJobResult(jobId, result); // Returns SQL only, no execution

  } catch (error) {
    setJobError(jobId, error.message);
  }
});
```

**New behavior:**
```javascript
const { handleGeneration } = require('../services/sqlGenerator');
const { validateSQL } = require('../services/sqlValidator');
const { pool } = require('../db');
const { updateJob, setJobResult, setJobError, JobStatus } = require('../utils/jobManager');

// In setImmediate callback (lines 74-110)
setImmediate(async () => {
  try {
    updateJob(jobId, JobStatus.PROCESSING);

    const sqlGenerationResult = await handleGeneration({
      question,
      userIdentifier,
      model,
    });

    // Check if generation failed
    if (!sqlGenerationResult || sqlGenerationResult.ok === false) {
      setJobResult(jobId, sqlGenerationResult); // Return validation failure
      return;
    }

    // Strip SQL out of the payload before further processing
    const {
      sql: rawSql,
      ...resultWithoutSql
    } = sqlGenerationResult || {};

    // Determine query type (handle missing field for single-shot mode)
    const queryType = sqlGenerationResult?.query_type || 'data_query';

    if (queryType !== 'data_query') {
      // Plot queries: behavior unchanged (SQL still required for plot renderer)
      setJobResult(jobId, sqlGenerationResult);
      return;
    }

    // NEW: Auto-execute data_query SQL
    console.log(`[sqlGenerator:${requestId}] Auto-executing data query for job ${jobId}`);

    if (!rawSql) {
      console.error(`[sqlGenerator:${requestId}] Missing SQL for data query job ${jobId}`);
      setJobError(jobId, 'No SQL was generated for this question.');
      return;
    }

    logger.info({
      requestId,
      jobId,
      sql_preview: rawSql.substring(0, 200)
    }, '[sqlGenerator] Data query SQL generated (server-log only)');

    // Validate SQL (already validated in handleGeneration, but check query_type-specific constraints)
    const validation = await validateSQL(rawSql, {
      schemaSnapshotId: sqlGenerationResult.metadata?.schema_snapshot_id,
      queryType: 'data_query'
    });

    if (!validation.valid) {
      // Validation failed (shouldn't happen, but handle gracefully)
      console.error(`[sqlGenerator:${requestId}] Data query re-validation failed`, validation.violations);
      setJobError(jobId, 'Query validation failed during execution');
      return;
    }

    // Execute validated SQL and count total rows
    const [executionResult, totalRowCount] = await Promise.all([
      executeDataQuery(validation.sqlWithLimit, userIdentifier),
      countTotalRows(validation.sqlWithLimit, userIdentifier)
    ]);

    // Combine SQL metadata + execution results
    // Combine non-SQL metadata + execution results
    const result = {
      ...resultWithoutSql,
      execution: {
        rows: executionResult.rows,
        rowCount: executionResult.rowCount,
        totalRowCount: totalRowCount, // Total available (before LIMIT)
        fields: executionResult.fields
      }
    };

    setJobResult(jobId, result);
    console.log(`[sqlGenerator:${requestId}] Data query executed: ${executionResult.rowCount} rows returned`);

  } catch (error) {
    console.error(`[sqlGenerator:${requestId}] Job failed:`, error);
    setJobError(jobId, error.message || 'Unexpected error during query execution');
  }
});
```

#### Helper Function: Execute Data Query

**Add to** `server/routes/sqlGenerator.js` (or create `server/utils/queryExecutor.js` if preferred):

```javascript
const { pool } = require('../db');

/**
 * Execute a data query (already validated SQL with LIMIT)
 * @param {string} sqlWithLimit - Validated SQL with LIMIT clause already enforced
 * @param {string} userIdentifier - User identifier for logging
 * @returns {Promise<{rows: Array, rowCount: number, fields: Array}>}
 */
async function executeDataQuery(sqlWithLimit, userIdentifier) {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');
    await client.query('SET LOCAL statement_timeout = 30000'); // Scoped to this transaction only

    // Execute query (SQL already validated and has LIMIT)
    const result = await client.query(sqlWithLimit);

    await client.query('COMMIT');

    return {
      rows: result.rows,
      rowCount: result.rowCount,
      fields: result.fields
    };
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

**SECURITY NOTE:**
- This function receives `sqlWithLimit` from `validation.sqlWithLimit` (not raw SQL)
- The validator has already:
  1. Checked for forbidden keywords (INSERT, UPDATE, DELETE, etc.)
  2. Validated with EXPLAIN plan (ensures read-only)
  3. Injected/clamped LIMIT clause (50 rows for data queries)
  4. Stripped comments and checked for placeholders
- **NEVER** pass raw LLM-generated SQL to this function
- **ALWAYS** pass `validation.sqlWithLimit` after calling `validateSQL()`

#### Helper Function: Count Total Rows

**Add to** `server/routes/sqlGenerator.js` (or `server/utils/queryExecutor.js`):

```javascript
const { pool } = require('../db');

/**
 * Count total rows available (before LIMIT) for pagination info
 * @param {string} sqlWithLimit - Validated SQL with LIMIT clause already enforced
 * @param {string} userIdentifier - User identifier for logging
 * @returns {Promise<number|null>} Total row count or null if count fails
 */
async function countTotalRows(sqlWithLimit, userIdentifier) {
  // Strip LIMIT clause from validated SQL to count total available rows
  // IMPORTANT: This SQL has already been validated by validateSQL(), so it's safe to manipulate

  let sqlWithoutLimit = sqlWithLimit
    .replace(/;?\s*$/i, '')       // Remove trailing semicolons and whitespace
    .replace(/--[^\n]*$/gm, '')   // Remove trailing line comments
    .trim();

  // Remove LIMIT clause (handles LIMIT N and LIMIT N OFFSET M)
  sqlWithoutLimit = sqlWithoutLimit.replace(/\s+LIMIT\s+\d+(?:\s+OFFSET\s+\d+)?\s*$/i, '');

  // Wrap in COUNT query
  const countSql = `SELECT COUNT(*) as total FROM (${sqlWithoutLimit}) as subq`;

  const client = await pool.connect();

  try {
    await client.query('BEGIN');
    await client.query('SET LOCAL statement_timeout = 5000');

    const result = await client.query(countSql);
    const total = parseInt(result.rows[0]?.total || 0, 10);

    await client.query('COMMIT');

    return total;
  } catch (err) {
    await client.query('ROLLBACK');
    // Count query failed (may timeout on complex queries)
    // Return null so frontend can use rowCount instead
    console.warn(`[countTotalRows] Failed to count total rows:`, err.message);
    return null;
  } finally {
    client.release();
  }
}
```

**SECURITY NOTE:**
- This function receives **validated SQL with LIMIT** from `validation.sqlWithLimit`
- The SQL has already passed 4-layer validation (regex, EXPLAIN, LIMIT enforcement, timeout)
- LIMIT stripping only removes the **validator-injected LIMIT**, not a bypass attempt
- COUNT wrapper operates on sanitized SQL that was already proven read-only via EXPLAIN

**Implementation Note:**
The LIMIT removal logic handles these cases:
- `LIMIT 50` → removed
- `LIMIT 50 OFFSET 10` → removed (both clauses)
- `LIMIT 50;` → semicolon stripped, then LIMIT removed
- `LIMIT 50 -- comment` → comment stripped, then LIMIT removed
- `LIMIT 50 OFFSET 10;` → all stripped correctly

The regex `/\s+LIMIT\s+\d+(?:\s+OFFSET\s+\d+)?\s*$/i` matches LIMIT with optional OFFSET at end of string (after trailing artifacts removed).

**Response Structure:**

**IMPORTANT:** The job endpoint returns a job envelope containing the SQL generation result. The frontend polls `GET /api/sql-generator/jobs/:jobId` and receives:

**Job Envelope (all query types):**
```json
{
  "jobId": "job_123456789_abc123",
  "status": "completed",
  "progress": 100,
  "result": { /* SQL generation result (see below) */ },
  "error": null,
  "createdAt": 1704470400000,
  "startedAt": 1704470401000,
  "completedAt": 1704470415000
}
```

**Data Query Result (NEW - inside job.result):**
> SQL text is intentionally omitted from this payload—only the backend logs contain the raw query.
```json
{
  "ok": true,
  "query_type": "data_query",
  "explanation": "Returns your latest cholesterol measurement",
  "execution": {
    "rows": [
      {
        "date": "2025-01-05",
        "value": 5.2,
        "unit": "ммоль/л",
        "reference_interval": "< 5.2"
      }
    ],
    "rowCount": 1,
    "totalRowCount": 1,
    "fields": [...]
  },
  "metadata": {
    "model": "gpt-4",
    "tokens": { "prompt": 0, "completion": 0, "total": 0 },
    "duration_ms": 2340,
    "schema_snapshot_id": "snapshot_123",
    "validator": { "ruleVersion": "v1.2.0", "strategy": "regex+explain_ro+plot" },
    "agentic": { "iterations": 3, "forced_completion": false }
  }
}
```

**Plot Query Result (UNCHANGED - inside job.result):**
```json
{
  "ok": true,
  "sql": "SELECT COALESCE(pr.test_date_text::timestamp, ...",
  "query_type": "plot_query",
  "explanation": "Time-series visualization of cholesterol",
  "plot_metadata": { "suggested_chart_title": "..." },
  "metadata": { /* same as above */ }
}
```

**Failed Validation Result (inside job.result when ok: false):**
```json
{
  "ok": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Only single read-only SELECT statements are allowed."
  },
  "details": {
    "violations": [
      { "code": "FORBIDDEN_KEYWORD", "keyword": "UPDATE" }
    ],
    "rule_version": "v1.2.0",
    "hint": "Rephrase your question without administrative keywords."
  },
  "metadata": { /* same as above */ }
}
```

**Note on SQL Visibility:**
- Data-query SQL never leaves the backend. It is logged for observability but omitted from job responses.
- Plot queries continue to include SQL in the payload because the existing chart renderer calls `/api/execute-sql` (unchanged behavior). No SQL is shown in the UI.

#### Logging Requirements

**Server-side logging:**
- Log generated SQL to `logger.info()` with context:
  ```javascript
  logger.info({
    userId,
    question,
    queryType: result.query_type,
    sql_preview: rawSql.substring(0, 200),
    executionTime: timer.elapsed()
  }, 'SQL query generated (stored server-side only)');
  ```
- Log execution results (row count, total count, errors):
  ```javascript
  logger.info({
    sql_preview: rawSql.substring(0, 200),
    rowCount: executionResult.rowCount,
    totalRowCount: totalRowCount
  }, 'Data query executed successfully');
  ```

**No UI logging:**
- SQL completely removed from frontend (no text box, no console.log)
- Users never see SQL text (only results)

---

### Frontend Changes

#### Remove SQL Display Components

**File:** `public/index.html`

**Remove these elements:**
```html
<!-- DELETE: SQL output section (entire div and all children) -->
<div id="sql-result" class="sql-result" style="display: none;">
  <h3>Generated SQL Query</h3>
  <div class="sql-output-container">
    <pre id="sql-output" class="sql-output"></pre>
    <button id="copy-sql-btn" class="btn-secondary">Copy SQL</button>
  </div>
  <div id="sql-notes" class="sql-notes"></div>
  <p class="model-info" id="model-info"></p>
</div>

<!-- DELETE: Regenerate button -->
<button id="sql-regenerate-btn" class="btn-secondary" style="display: none;">
  Regenerate
</button>
```

**Keep for plot queries:**
```html
<!-- KEEP: Plot visualization container (unchanged) -->
<div id="plot-visualization-container" class="plot-visualization-container">
  <!-- Parameter selector, chart, parameter table -->
</div>
```

**Add for data queries:**
```html
<!-- NEW: Data query results section -->
<div id="data-results-section" class="data-results-section" style="display: none;">
  <div class="results-header">
    <h3>Query Results</h3>
    <p id="row-count-message" class="row-count-message"></p>
  </div>
  <div class="parameters-table-wrapper">
    <table id="data-results-table" class="parameters-table">
      <thead>
        <tr>
          <th scope="col">Date</th>
          <th scope="col">Value</th>
          <th scope="col">Unit</th>
          <th scope="col">Reference Interval</th>
        </tr>
      </thead>
      <tbody id="data-results-tbody">
        <!-- Populated dynamically -->
      </tbody>
    </table>
  </div>
</div>
```

#### Update SQL Generator Bootstrap Guard

Removing the SQL output elements makes the existing initialization guard in `public/js/app.js` falsey (it currently requires `sqlCopyBtn`, `sqlResultEl`, and `sqlOutputEl`). Update the condition so that it only checks for the elements that still exist (e.g., `sqlQuestionInput` and `sqlGenerateBtn`) and wire up any new nodes (`data-results-section`, `row-count-message`, etc.) above the guard. This ensures the SQL generation flow remains active after the DOM changes.

#### Update SQL Result Rendering

**File:** `public/js/app.js`

**CRITICAL: Do NOT delete `renderSqlResult()`!**

**Context:** `renderSqlResult()` (lines 1251-1358) is the main dispatcher function called by the job polling logic (line 1458). It:
- Cleans up previous charts
- Manages UI state (hiding/showing containers)
- Routes based on `query_type` to either plot or data rendering

Deleting it would break the entire SQL generation flow, including plot queries.

**Refactor function:** `renderSqlResult()` (lines 1251-1358)

**Changes to existing code:**
- **KEEP:** Chart cleanup logic (lines 1256-1266)
- **KEEP:** Plot container hiding logic (lines 1268-1282)
- **DELETE:** SQL text box population (lines 1284-1291)
- **DELETE:** Explanation rendering (lines 1325-1330)
- **DELETE:** Model metadata display (lines 1294-1310)
- **KEEP:** Plot query routing (lines 1344-1357)
- **ADD:** Data query routing (new branch for `query_type === 'data_query'`)

**Refactored structure:**

```javascript
const renderSqlResult = (payload) => {
  if (!payload || typeof payload !== 'object') {
    return;
  }

  // KEEP: Cleanup previous chart if exists
  if (currentChart && window.plotRenderer) {
    window.plotRenderer.destroyChart(currentChart);
    currentChart = null;
  }

  const parameterListEl = document.getElementById('parameter-list');
  if (parameterListEl && parameterSelectorChangeHandler) {
    parameterListEl.removeEventListener('change', parameterSelectorChangeHandler);
    parameterSelectorChangeHandler = null;
  }

  // KEEP: Hide plot container and wrapper by default
  const plotContainer = document.getElementById('plot-container');
  const visualizationContainer = document.getElementById('plot-visualization-container');
  if (visualizationContainer) {
    visualizationContainer.hidden = true;
  }
  if (plotContainer) {
    plotContainer.hidden = true;
  }
  const plotResetBtn = document.getElementById('plot-reset-btn');
  if (plotResetBtn) {
    plotResetBtn.hidden = true;
    plotResetBtn.disabled = true;
    plotResetBtn.onclick = null;
  }

  // NEW: Always hide/reset the data results section before routing
  const dataResultsSection = document.getElementById('data-results-section');
  const dataResultsTbody = document.getElementById('data-results-tbody');
  const rowCountMsg = document.getElementById('row-count-message');
  if (dataResultsSection) {
    dataResultsSection.style.display = 'none';
  }
  if (dataResultsTbody) {
    dataResultsTbody.innerHTML = '';
  }
  if (rowCountMsg) {
    rowCountMsg.textContent = '';
  }

  // DELETE: SQL display logic (lines 1284-1342 in original)
  // - No SQL text box population
  // - No explanation rendering
  // - No model metadata
  // - No confidence display
  // - No "Copy SQL" button handling
  // - No "Regenerate" button handling (button deleted from UI)

  // NEW: Route based on query type
  // Handle missing query_type (single-shot mode compatibility)
  const queryType = payload.query_type || 'data_query'; // Default to data_query if missing

  // Log warning if query_type is missing (helps debug single-shot mode issues)
  if (!payload.query_type) {
    console.warn('[renderSqlResult] query_type field missing, defaulting to data_query. This may indicate agentic mode is disabled.');
  }

  if (queryType === 'plot_query') {
    // KEEP: Existing plot rendering logic
    if (dataResultsSection) {
      dataResultsSection.style.display = 'none';
    }
    setTimeout(() => {
      if (window.plotRenderer) {
        renderPlotVisualization(payload).catch(err => {
          console.error('[app] Plot rendering failed:', err);
        });
      } else {
        console.error('[app] plotRenderer not available');
      }
    }, 100);
  } else {
    // NEW: Data query rendering
    renderDataQueryResults(payload);
  }
};
```

**Key points:**
- Function remains as dispatcher called by `performSqlGeneration()` (line 1458)
- Chart cleanup and UI state management preserved
- SQL display code removed
- Query type routing preserved for plots, added for data queries
- No breaking changes to call sites or plot flow

**Add new function:** `renderDataQueryResults(payload)`

```javascript
/**
 * Renders tabular results for data_query type queries
 * @param {Object} payload - SQL generation result with execution data
 * @param {Object} payload.execution - Execution results
 * @param {Array} payload.execution.rows - Result rows
 * @param {number} payload.execution.rowCount - Number of rows returned
 * @param {number} payload.execution.totalRowCount - Total rows available (before LIMIT)
 */
function renderDataQueryResults(payload) {
  const section = document.getElementById('data-results-section');
  const tbody = document.getElementById('data-results-tbody');
  const rowCountMsg = document.getElementById('row-count-message');

  // Clear previous results
  tbody.innerHTML = '';

  // Validate execution data
  if (!payload.execution || !payload.execution.rows) {
    showError('No execution results available');
    section.style.display = 'none';
    return;
  }

  const { rows, rowCount, totalRowCount } = payload.execution;

  // Handle empty results
  if (rowCount === 0) {
    tbody.innerHTML = '<tr><td colspan="4" class="no-data">No data found for your query</td></tr>';
    rowCountMsg.textContent = 'No results found';
    section.style.display = 'block';
    return;
  }

  // Validate required column aliases (prevent broken UI)
  if (rowCount > 0) {
    const firstRow = rows[0];
    const requiredColumns = ['date', 'value', 'unit', 'reference_interval'];
    const missingColumns = requiredColumns.filter(col => !(col in firstRow));

    if (missingColumns.length > 0) {
      console.error('[renderDataQueryResults] Missing required columns:', missingColumns, 'requestId:', payload.metadata?.request_id);
      showError(`Query results are missing required columns: ${missingColumns.join(', ')}. Please try rephrasing your question.`);
      section.style.display = 'none';
      return;
    }
  }

  // Render row count message
  if (totalRowCount && totalRowCount > rowCount) {
    rowCountMsg.textContent = `Showing ${rowCount} of ${totalRowCount} total rows`;
  } else {
    rowCountMsg.textContent = `Found ${rowCount} row${rowCount !== 1 ? 's' : ''}`;
  }

  // Render table rows
  rows.forEach(row => {
    const tr = document.createElement('tr');

    // Date column
    const dateCell = document.createElement('td');
    dateCell.textContent = formatDate(row.date) || 'N/A';
    tr.appendChild(dateCell);

    // Value column (with out-of-range highlighting)
    const valueCell = document.createElement('td');
    valueCell.textContent = row.value !== null ? row.value : 'N/A';

    // Apply out-of-range styling if applicable
    if (shouldHighlightOutOfRange(row)) {
      valueCell.setAttribute('data-out-of-range', 'true');
    }
    tr.appendChild(valueCell);

    // Unit column
    const unitCell = document.createElement('td');
    unitCell.textContent = row.unit || '';
    tr.appendChild(unitCell);

    // Reference Interval column
    const refCell = document.createElement('td');
    refCell.textContent = row.reference_interval || 'Unavailable';
    tr.appendChild(refCell);

    tbody.appendChild(tr);
  });

  section.style.display = 'block';
}

/**
 * Determines if a value should be highlighted as out-of-range
 * @param {Object} row - Data row
 * @returns {boolean}
 */
function shouldHighlightOutOfRange(row) {
  // Use database flag if available
  if (row.is_value_out_of_range !== undefined) {
    return row.is_value_out_of_range;
  }

  // Fallback: compute client-side
  const value = parseFloat(row.value);
  if (isNaN(value)) return false;

  const lower = parseFloat(row.reference_lower);
  const upper = parseFloat(row.reference_upper);

  if (!isNaN(lower) && value < lower) return true;
  if (!isNaN(upper) && value > upper) return true;

  return false;
}

/**
 * Formats date string or timestamp to readable format
 * @param {string|number} date - ISO string, Unix timestamp, or formatted date
 * @returns {string}
 */
function formatDate(date) {
  if (!date) return '';

  try {
    const d = new Date(date);
    if (isNaN(d.getTime())) return date; // Return as-is if invalid

    return d.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    }); // e.g., "Jan 15, 2024"
  } catch (err) {
    return date; // Return original on error
  }
}

/**
 * Escapes HTML special characters to prevent XSS attacks
 * @param {string} str - String to escape
 * @returns {string} - HTML-safe string
 */
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}
```

#### Update Main Rendering Logic

**File:** `public/js/app.js` (lines 1439-1475 in actual code)

**UPDATE REQUIRED:** Job polling completion and error handlers need status message updates.

The existing code at line 1458 calls `renderSqlResult(result)` but uses outdated status messages. Update both success and error paths:

```javascript
// Current code structure (lines 1439-1475)
if (jobStatus.status === 'completed') {
  const result = jobStatus.result;

  // Check if result indicates validation failure
  if (!result || result.ok === false) {
    // Handle validation failure
    const errorMessage = result?.error && isNonEmptyString(result.error.message)
      ? result.error.message
      : 'Generated SQL failed validation.';
    const hint = result?.details && isNonEmptyString(result.details.hint)
      ? ` ${result.details.hint}`
      : '';
    throw new Error(`${errorMessage}${hint}`);
  }

  lastQuestion = result && isNonEmptyString(result.question)
    ? result.question
    : inputValue;

  renderSqlResult(result);  // Line 1458 - UNCHANGED

  // UPDATE: Set status message based on query type (no longer references "SQL review")
  const queryType = result.query_type || 'data_query'; // Default to data_query for single-shot mode
  if (queryType === 'plot_query') {
    setSqlStatus('Visualization generated successfully.', 'success');
  } else if (queryType === 'data_query') {
    setSqlStatus('Query results displayed below.', 'success');
  } else {
    // Fallback for unknown query types
    setSqlStatus('Query completed successfully.', 'success');
  }

  return; // Done!

} else if (jobStatus.status === 'failed') {
  // Job failed - UPDATE: Remove "review before using" language
  const errorMessage = jobStatus.error || 'Query generation failed.';
  throw new Error(errorMessage);
}
```

**Changes:**
- `renderSqlResult()` call remains unchanged (handles routing internally)
- **Success path:** Status message reflects query type (no longer references SQL review)
  - Plot queries → "Visualization generated successfully"
  - Data queries → "Query results displayed below"
  - Defaults to 'data_query' if `query_type` missing (handles single-shot mode)
- **Error path:** Simplified error message (no longer mentions "review before using externally")
- The refactored `renderSqlResult()` function handles routing:
  - Plot queries → calls `renderPlotVisualization(payload)`
  - Data queries → calls `renderDataQueryResults(payload)`

This preserves backward compatibility and avoids breaking existing plot query functionality.

#### Error Handling

**Display error messages in UI:**

```javascript
function showError(message) {
  const section = document.getElementById('data-results-section');
  const tbody = document.getElementById('data-results-tbody');
  const rowCountMsg = document.getElementById('row-count-message');

  tbody.innerHTML = `<tr><td colspan="4" class="error-message">${escapeHtml(message)}</td></tr>`;
  rowCountMsg.textContent = '';
  section.style.display = 'block';
}
```

**Error scenarios:**

| Error | Message |
|-------|---------|
| Query execution timeout (30s) | "Query timed out. Please try a simpler question or smaller date range." |
| SQL validation failed | "Unable to execute query safely. Please rephrase your question." |
| No results returned | "No data found for your query" |
| Backend execution error | "An error occurred while fetching your data. Please try again." |
| Network/API failure | "Unable to reach server. Please check your connection." |

---

### CSS Changes

**File:** `public/css/style.css`

**Important:** Before implementing CSS, verify that CSS variables `--text-secondary` and `--error-color` exist in the current stylesheet. If not defined, add them to the `:root` selector:

```css
:root {
  --text-secondary: #6c757d;
  --error-color: #dc3545;
}
```

**Add styles for data results section:**

```css
/* Data query results section */
.data-results-section {
  margin-top: 2rem;
}

.results-header {
  margin-bottom: 1rem;
}

.results-header h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
}

.row-count-message {
  color: var(--text-secondary);
  font-size: 0.9rem;
  margin: 0;
}

/* Reuse existing parameter table styles */
.data-results-section .parameters-table {
  /* Inherits from .parameters-table (no changes needed) */
}

/* Out-of-range highlighting (reuse existing style) */
.data-results-section td[data-out-of-range='true'] {
  outline: 2px solid var(--error-color);
  outline-offset: -2px;
}

/* Empty state / error messages */
.data-results-section .no-data,
.data-results-section .error-message {
  text-align: center;
  padding: 2rem;
  color: var(--text-secondary);
  font-style: italic;
}

.data-results-section .error-message {
  color: var(--error-color);
}
```

**Remove unused styles:**
```css
/* DELETE: SQL output and button styles */
.sql-result { /* ... */ }
.sql-output-container { /* ... */ }
.sql-output { /* ... */ }
#copy-sql-btn { /* ... */ }
.sql-notes { /* ... */ }
#sql-regenerate-btn { /* ... */ }
.model-info { /* ... */ }
```

---

## SQL Output Format Requirements

### Required Columns

For data queries to render correctly in the table, the LLM-generated SQL must include these column aliases:

| Column Alias | Type | Description | Example |
|--------------|------|-------------|---------|
| `date` | TEXT/TIMESTAMP | Test date | `'2025-01-05'` |
| `value` | NUMERIC | Measurement value | `5.2` |
| `unit` | TEXT | Unit of measurement | `'ммоль/л'` |
| `reference_interval` | TEXT | Formatted interval | `'< 5.2'`, `'30 - 100'` |

### Optional Columns

| Column Alias | Type | Description | Usage |
|--------------|------|-------------|-------|
| `is_value_out_of_range` | BOOLEAN | Out-of-range flag | Red outline on Value cell |
| `reference_lower` | NUMERIC | Lower bound | Fallback for out-of-range check |
| `reference_upper` | NUMERIC | Upper bound | Fallback for out-of-range check |
| `parameter_name` | TEXT | Analyte name | Potential future use |

### SQL Template Example

**Prompt engineering adjustment** (`server/services/agenticSqlGenerator.js`):

Update `generate_final_query` tool schema to include data query guidelines:

```javascript
// In tool definition (lines 393-450)
sql: {
  type: "string",
  description: `
    SQL query with appropriate column aliases.

    For data_query (tabular results):
    - REQUIRED aliases: date, value, unit, reference_interval
    - OPTIONAL: is_value_out_of_range, parameter_name
    - Format reference_interval as readable string (e.g., '< 5.2', '30 - 100')
    - Use COALESCE for null handling

    Example:
    SELECT
      test_date as date,
      value,
      unit,
      CASE
        WHEN reference_lower IS NOT NULL AND reference_upper IS NOT NULL
          THEN reference_lower || ' - ' || reference_upper
        WHEN reference_lower IS NOT NULL
          THEN '>= ' || reference_lower
        WHEN reference_upper IS NOT NULL
          THEN '<= ' || reference_upper
        ELSE NULL
      END as reference_interval,
      (value < reference_lower OR value > reference_upper) as is_value_out_of_range
    FROM v_measurements
    WHERE parameter_name ILIKE '%cholesterol%'
    ORDER BY test_date DESC
    LIMIT 50;
  `
}
```

**Note:** Existing agentic tools (`fuzzy_search_parameter_names`, `execute_exploratory_sql`) already provide schema awareness. No changes to tool definitions needed, only to final query documentation.

---

## Acceptance Criteria

### Backend

- [ ] **Job processor uses correct APIs (Finding #1 fix):**
  - [ ] Uses `handleGeneration({ question, userIdentifier, model })` (not phantom `generateSQL()`)
  - [ ] Uses `setJobResult(jobId, result)` (not `updateJob(jobId, 'completed', 100, result)`)
  - [ ] Uses `setJobError(jobId, errorMessage)` for failures
  - [ ] Uses `updateJob(jobId, JobStatus.PROCESSING)` for status updates
- [ ] **Validator uses correct contract (Finding #3 fix - SECURITY CRITICAL):**
  - [ ] Calls `validateSQL(sql, { schemaSnapshotId, queryType })`
  - [ ] Uses `validation.sqlWithLimit` (not `validation.sql`) for execution
  - [ ] Never executes raw LLM SQL (always uses `sqlWithLimit`)
  - [ ] DB pool imported as `const { pool } = require('../db')` (not `dbPool.getPool()`)
- [ ] **Single-shot mode handled gracefully (Finding #5 fix):**
  - [ ] Checks for missing `query_type` field
  - [ ] Defaults to `'data_query'` if `query_type` missing
  - [ ] Logs warning when `query_type` missing
  - [ ] Works correctly even if `AGENTIC_SQL_ENABLED=false` (falls back to data query execution)
- [ ] `POST /api/sql-generator` job processor executes `data_query` SQL automatically
- [ ] Backend returns execution results in `execution` field: `{ rows, rowCount, totalRowCount, fields }`
- [ ] **Response uses correct envelope structure (Finding #2 fix):**
  - [ ] Job status returns `{ jobId, status, result, error, ... }`
  - [ ] Data-query results contain `{ ok, query_type, execution, metadata }` (no `sql` field)
  - [ ] Plot queries continue to include SQL for chart rendering (unchanged contract)
- [ ] Total row count calculated correctly (strips LIMIT, wraps in COUNT query)
- [ ] **Count query handles edge cases correctly (P2 fix):**
  - [ ] `LIMIT 50` → removed, count query succeeds
  - [ ] `LIMIT 50 OFFSET 10` → both clauses removed, count returns total (not capped at 50)
  - [ ] `LIMIT 50;` → semicolon stripped, count query succeeds
  - [ ] `LIMIT 50 -- comment` → comment stripped, count query succeeds
  - [ ] `LIMIT 50 OFFSET 10;` → all artifacts stripped, count correct
- [ ] Execution failures caught and returned as job errors (status: `failed`)
- [ ] SQL logged to server logs with context (userId, question, queryType, executionTime)
- [ ] Execution results logged (rowCount, totalRowCount)
- [ ] Security validation applied (same 4-layer validation as plot queries)
- [ ] Timeout enforced (30 seconds for execution, 5 seconds for count query)
- [ ] Plot query behavior unchanged (still returns SQL only, no execution)
- [ ] Data-query SQL logged server-side with request/job identifiers and never leaves the backend
- [ ] Statement timeouts set via `SET LOCAL ...` inside transactions so pooled clients revert automatically

### Frontend

- [ ] **`renderSqlResult()` refactored correctly (P1 fix):**
  - [ ] Function still exists and is called by job polling logic (line 1458)
  - [ ] Chart cleanup logic preserved (lines 1256-1266)
  - [ ] UI state management preserved (lines 1268-1282)
  - [ ] SQL display code removed (lines 1284-1342)
  - [ ] Query type routing works: plot queries call `renderPlotVisualization()`, data queries call `renderDataQueryResults()`
- [ ] SQL text box completely removed from UI for both query types
- [ ] SQL explanation box removed
- [ ] "Copy SQL" button removed
- [ ] "Regenerate" button removed
- [ ] SQL generator bootstrap logic no longer depends on removed DOM nodes (`sqlCopyBtn`, `sqlResultEl`, `sqlOutputEl`)
- [ ] **Status messages updated (Finding #4 fix):**
  - [ ] Success for plot queries: "Visualization generated successfully"
  - [ ] Success for data queries: "Query results displayed below"
  - [ ] Error messages no longer reference "review before using externally"
  - [ ] Defaults to 'data_query' if `query_type` missing (single-shot mode)
- [ ] **Single-shot mode compatibility (Finding #5 fix):**
  - [ ] Handles missing `query_type` field gracefully
  - [ ] Defaults to rendering as data query
  - [ ] Logs warning when `query_type` missing
- [ ] Data query results render in table with 4 columns: Date, Value, Unit, Reference Interval
- [ ] Row count message displays correctly:
  - "Showing 50 of 120 total rows" when limited
  - "Found 12 rows" when all results shown
  - "No results found" when rowCount = 0
- [ ] Data results section is cleared/hidden whenever a new job begins or when rendering a plot query
- [ ] Out-of-range values highlighted with red outline on Value cell
- [ ] Date formatting works correctly (Unix timestamp → "Jan 15, 2024")
- [ ] Empty reference intervals show "Unavailable"
- [ ] Column alias validation works (shows error if required columns missing)
- [ ] Error messages display in table area (timeout, validation, execution errors)
- [ ] `escapeHtml()` function prevents XSS in error messages
- [ ] No console errors in browser dev tools
- [ ] Responsive table wrapper (horizontal scroll on narrow viewports)

### Regression Testing

- [ ] **`renderSqlResult()` refactoring doesn't break plot queries (P1 fix):**
  - [ ] Job polling completion handler still calls `renderSqlResult()` (line 1458)
  - [ ] Plot queries still trigger chart rendering
  - [ ] No JavaScript errors in console after refactoring
  - [ ] Chart cleanup still works (old charts destroyed before new ones)
  - [ ] UI state transitions work (containers shown/hidden correctly)
- [ ] Plot queries render charts correctly (no changes to plot flow)
- [ ] Parameter selector works for plot queries
- [ ] Parameter table below plot still renders (no layout issues)
- [ ] Chart zoom/pan functionality unchanged
- [ ] SQL generation polling works for both query types
- [ ] Loading states display correctly
- [ ] Agentic SQL tool calls logged correctly

### QA Test Scenarios

#### Data Query Tests

1. **Simple latest value query:**
   - Question: "покажи мне мой последний холестерин"
   - Expected: 1 row table with most recent cholesterol measurement
   - Verify: Date, value, unit, reference interval all populated

2. **Multiple results query:**
   - Question: "show all my vitamin D tests from 2024"
   - Expected: Multiple rows (up to 50) with proper sorting
   - Verify: Row count message shows correct total

3. **Limited results query:**
   - Question: "list all my lab tests" (assume >50 results)
   - Expected: 50 rows displayed
   - Verify: Message shows "Showing 50 of X total rows"

4. **No results query:**
   - Question: "show my tests for parameter XYZ" (doesn't exist)
   - Expected: Empty table with "No data found for your query"
   - Verify: No errors in console

5. **Out-of-range highlighting:**
   - Question: "show my cholesterol tests with abnormal results"
   - Expected: Rows with out-of-range values have red outline on Value cell
   - Verify: `data-out-of-range='true'` attribute applied

6. **Missing reference intervals:**
   - Question: "show tests without reference ranges"
   - Expected: Reference Interval column shows "Unavailable"
   - Verify: No red outline on Value cell

#### Error Handling Tests

7. **Timeout scenario:**
   - Simulate slow query (>30s execution)
   - Expected: Error message: "Query timed out..."
   - Verify: Job status = `failed`, error displayed in table

8. **Invalid SQL scenario:**
   - Force validation failure (e.g., inject forbidden keyword)
   - Expected: Error message: "Unable to execute query safely..."
   - Verify: No query executed, error logged

9. **Network failure:**
   - Disconnect network during polling
   - Expected: Error message: "Unable to reach server..."
   - Verify: Graceful degradation

#### Plot Query Regression Tests

10. **Plot query unchanged:**
    - Question: "show my cholesterol trend over time"
    - Expected: Chart renders, parameter table displays below
    - Verify: No SQL text box visible, plot functionality intact

11. **Plot query with multiple parameters:**
    - Question: "show cholesterol, HDL, LDL trends"
    - Expected: Parameter selector works, chart updates on selection
    - Verify: Parameter table synchronized with chart

---

## Migration & Deployment Plan

### Phase 1: Backend Implementation (1-2 days)

1. **Add execution logic** to SQL generator job processor:
   - Implement `executeDataQuery()` helper function
   - Implement `countTotalRows()` helper function
   - Update job completion handler to execute data queries
   - Add structured logging for execution results

2. **Test backend thoroughly:**
   - Execute data queries via API (Postman/curl)
   - Verify response structure includes `execution` field
   - Test row count logic (compare totalRowCount vs rowCount)
   - Test error handling (invalid SQL, timeout, validation failures)
   - Review server logs for SQL visibility

3. **Update API documentation:**
   - Document new response format for data queries
   - Update `/api/sql-generator` endpoint spec

### Phase 2: Frontend Implementation (1-2 days)

1. **Remove SQL display components:**
   - Delete entire `#sql-result` div from `index.html`
   - Delete `#sql-regenerate-btn` button from `index.html`
   - Delete "Copy SQL" button logic from `app.js`
   - Delete related CSS styles (`.sql-output`, `.sql-notes`, `#sql-regenerate-btn`, etc.)

2. **Refactor dispatcher function (DO NOT DELETE):**
   - **Refactor** `renderSqlResult()` function in `app.js` (lines 1251-1358)
   - **KEEP:** Chart cleanup logic, UI state management
   - **REMOVE:** SQL text box population code (lines 1284-1342)
   - **ADD:** Data query routing branch (`if/else` on `query_type`)
   - **NO CHANGES** to call site (line 1458 remains `renderSqlResult(result)`)

3. **Add data results rendering:**
   - Add new HTML section for data results table in `index.html`
   - Implement `renderDataQueryResults()` function with column alias validation
   - Implement helper functions: `formatDate()`, `shouldHighlightOutOfRange()`, `escapeHtml()`, `showError()`
   - Update job polling completion handler to set status messages based on query type

4. **Add CSS styles:**
   - Verify CSS variables `--text-secondary` and `--error-color` exist (add if missing)
   - Style data results section
   - Reuse parameter table styles
   - Add error message styles

### Phase 3: Testing & QA (2-3 days)

**Test Data Requirements:**
Before beginning QA, ensure test database contains:
- At least 60 lab results for one test patient (to test LIMIT 50 pagination)
- Results with complete reference intervals (both lower and upper bounds)
- Results with partial reference intervals (only lower OR only upper)
- Results with missing reference intervals (NULL values)
- Results with out-of-range values (above/below reference intervals)
- Common analytes: Total Cholesterol, HDL, LDL, Vitamin D, Glucose, Hemoglobin
- Parameter names in both Russian (Cyrillic) and English
- Various date ranges (2023, 2024, 2025)
- Duplicate measurements (same analyte, different dates)

1. **Functional testing:**
   - Test all 11 QA scenarios listed in Acceptance Criteria
   - Verify data query execution and rendering
   - Verify plot query behavior unchanged
   - Test error handling scenarios

2. **Cross-browser testing:**
   - Chrome, Firefox, Safari, Edge
   - Verify table rendering and styling consistency

3. **Accessibility testing:**
   - Keyboard navigation
   - Screen reader compatibility
   - Semantic HTML validation

4. **Performance testing:**
   - Test with large result sets (50 rows)
   - Measure table rendering time
   - Verify no memory leaks

### Phase 4: Deployment (1 day)

1. **Deploy to staging:**
   - Monitor logs for SQL execution traces
   - Verify no errors in production logs

2. **User acceptance testing:**
   - Test with real user questions in Russian and English
   - Collect feedback on result formatting

3. **Deploy to production:**
   - Monitor for errors
   - Check analytics for usage patterns

### Phase 5: Documentation Update (1 day)

1. **Update CLAUDE.md:**
   - Document new data query execution flow
   - Update frontend architecture section
   - Add SQL output format requirements

2. **Update user documentation:**
   - Add examples of data queries
   - Explain row count limits
   - Document error messages

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| **SQL injection** | High | Existing 4-layer validation prevents injection (regex, EXPLAIN plan, forbidden keywords) |
| **Performance regression** | Medium | Row counts limited to 50 (data) / 10,000 (plot); LIMIT enforced in validator |
| **Timeout on complex queries** | Medium | 30-second timeout enforced; count query has 5-second timeout; errors handled gracefully |
| **Missing column aliases** | High | Update LLM prompt to emphasize required aliases; frontend validation checks for required columns and shows user-friendly error |
| **Incorrect row count** | Low | COUNT query may timeout; fallback to `rowCount` from execution (frontend shows "Found X rows" without total) |
| **Plot query regression** | Medium | Comprehensive regression testing; no changes to plot rendering logic |
| **SQL visibility loss for debugging** | Low | SQL fully logged on server; developers can access logs; no user-facing impact |

---

## Success Metrics

### User Experience Metrics
- **Data query completion rate:** >95% of data queries successfully display results
- **Error rate:** <5% of queries fail execution
- **User satisfaction:** Positive feedback on result clarity (vs. SQL display)

### Technical Metrics
- **Execution time:** <2 seconds median (p50) for data queries
- **Execution time:** <5 seconds p95 for data queries
- **Count query success rate:** >90% of count queries complete within timeout
- **Frontend render time:** <100ms to render 50-row table

### Business Metrics
- **Feature adoption:** Data queries account for >40% of total SQL generation requests
- **User retention:** Users with successful data query results have higher return rate
- **Support tickets:** Reduction in "how do I execute SQL" questions

---

## Appendix: Example Scenarios

### Example 1: Latest Value Query

**User Question (Russian):**
```
покажи мне мой последний холестерин
```

**LLM-Generated SQL:**
```sql
SELECT
  pr.test_date::date as date,
  lr.value,
  lr.unit,
  CASE
    WHEN lr.reference_upper IS NOT NULL
      THEN '<= ' || lr.reference_upper
    ELSE NULL
  END as reference_interval,
  (lr.value > lr.reference_upper) as is_value_out_of_range
FROM lab_results lr
JOIN patient_reports pr ON lr.report_id = pr.id
WHERE lr.parameter_name ILIKE '%cholesterol%'
  AND lr.parameter_name ILIKE '%total%'
ORDER BY pr.test_date DESC
LIMIT 1;
```

**Rendered Table:**

```
Query Results
Found 1 row

┌─────────────┬───────┬─────────┬─────────────────────┐
│ Date        │ Value │ Unit    │ Reference Interval  │
├─────────────┼───────┼─────────┼─────────────────────┤
│ Jan 5, 2025 │ 5.2   │ ммоль/л │ <= 5.2              │
│             │ ⚠️    │         │                     │
└─────────────┴───────┴─────────┴─────────────────────┘

Note: ⚠️ = red outline on Value cell (out of range)
```

### Example 2: Multiple Results Query

**User Question (English):**
```
show all my vitamin D tests from 2024
```

**LLM-Generated SQL:**
```sql
SELECT
  pr.test_date::date as date,
  lr.value,
  lr.unit,
  CASE
    WHEN lr.reference_lower IS NOT NULL AND lr.reference_upper IS NOT NULL
      THEN lr.reference_lower || ' - ' || lr.reference_upper
    WHEN lr.reference_lower IS NOT NULL
      THEN '>= ' || lr.reference_lower
    ELSE NULL
  END as reference_interval,
  (lr.value < lr.reference_lower OR lr.value > lr.reference_upper) as is_value_out_of_range
FROM lab_results lr
JOIN patient_reports pr ON lr.report_id = pr.id
WHERE lr.parameter_name ILIKE '%vitamin d%'
  AND EXTRACT(YEAR FROM pr.test_date) = 2024
ORDER BY pr.test_date DESC
LIMIT 50;
```

**Rendered Table:**

```
Query Results
Found 8 rows

┌──────────────┬───────┬───────┬─────────────────────┐
│ Date         │ Value │ Unit  │ Reference Interval  │
├──────────────┼───────┼───────┼─────────────────────┤
│ Dec 15, 2024 │ 42    │ ng/mL │ 30 - 100            │
│ Sep 10, 2024 │ 28    │ ng/mL │ 30 - 100            │
│              │ ⚠️    │       │                     │
│ Jun 5, 2024  │ 35    │ ng/mL │ 30 - 100            │
│ Mar 20, 2024 │ 31    │ ng/mL │ 30 - 100            │
│ ...          │ ...   │ ...   │ ...                 │
└──────────────┴───────┴───────┴─────────────────────┘
```

### Example 3: Limited Results Query

**User Question:**
```
list all my lab tests
```

**Backend Response:**
```json
{
  "execution": {
    "rowCount": 50,
    "totalRowCount": 147,
    "rows": [...]
  }
}
```

**Rendered UI:**

```
Query Results
Showing 50 of 147 total rows

┌─────────────┬───────┬─────────┬─────────────────────┐
│ Date        │ Value │ Unit    │ Reference Interval  │
├─────────────┼───────┼─────────┼─────────────────────┤
│ Jan 5, 2025 │ 5.2   │ ммоль/л │ < 5.2               │
│ Dec 10,2024 │ 42    │ ng/mL   │ 30 - 100            │
│ ...         │ ...   │ ...     │ ...                 │
└─────────────┴───────┴─────────┴─────────────────────┘
```

---

**End of PRD v3.1**
